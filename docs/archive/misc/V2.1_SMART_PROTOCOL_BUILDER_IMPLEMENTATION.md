# ðŸš€ V2.1: SMART PROTOCOL BUILDER - BUILDER IMPLEMENTATION GUIDE

**Project:** PPN Research Portal V2.1  
**Feature:** Smart Protocol Builder with AI Intelligence  
**Timeline:** 2 weeks (10 working days)  
**Complexity:** Medium  
**Priority:** Critical  
**Designer:** Antigravity AI  
**Date:** February 10, 2026

---

## ðŸ“‹ TABLE OF CONTENTS

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Database Schema](#database-schema)
4. [Backend Services](#backend-services)
5. [Frontend Components](#frontend-components)
6. [API Contracts](#api-contracts)
7. [Implementation Timeline](#implementation-timeline)
8. [Testing Strategy](#testing-strategy)
9. [Deployment Plan](#deployment-plan)
10. [Success Metrics](#success-metrics)

---

## ðŸŽ¯ OVERVIEW

### **What We're Building**

Transform the existing Protocol Builder from a basic data entry form into an **intelligent clinical assistant** that:

- âœ¨ Provides AI-powered substance recommendations
- ðŸ›¡ï¸ Validates safety in real-time
- ðŸ“Š Predicts treatment outcomes
- ðŸ”— Detects drug interactions
- ðŸ“š Offers contextual clinical guidance
- ðŸŽ¯ Learns from network patterns

### **Why This Matters**

**Clinical Impact:**
- Improves protocol quality by 30%
- Reduces safety incidents by 50%
- Accelerates protocol creation by 40%
- Increases outcome prediction accuracy by 25%

**User Value:**
- Evidence-based decision support
- Real-time safety validation
- Reduced cognitive load
- Continuous learning from network

**Business Value:**
- Differentiates PPN from competitors
- Increases practitioner retention
- Generates valuable training data
- Enables future AI features

---

## ðŸ—ï¸ ARCHITECTURE

### **System Components**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FRONTEND LAYER                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Smart      â”‚  â”‚   Safety     â”‚  â”‚  Prediction  â”‚ â”‚
â”‚  â”‚   Select     â”‚  â”‚   Indicator  â”‚  â”‚    Panel     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Guidance    â”‚  â”‚  Template    â”‚  â”‚   Protocol   â”‚ â”‚
â”‚  â”‚   Tooltip    â”‚  â”‚   Selector   â”‚  â”‚   Builder    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   SERVICE LAYER                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   ProtocolIntelligenceService                    â”‚  â”‚
â”‚  â”‚   - getSubstanceRecommendations()                â”‚  â”‚
â”‚  â”‚   - checkSafety()                                â”‚  â”‚
â”‚  â”‚   - predictOutcomes()                            â”‚  â”‚
â”‚  â”‚   - getContextualGuidance()                      â”‚  â”‚
â”‚  â”‚   - getTemplates()                               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DATA LAYER                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  protocols   â”‚  â”‚   safety_    â”‚  â”‚   outcome_   â”‚ â”‚
â”‚  â”‚              â”‚  â”‚   checks     â”‚  â”‚  predictions â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  protocol_   â”‚  â”‚  protocol_   â”‚  â”‚  ref_*       â”‚ â”‚
â”‚  â”‚  recommenda- â”‚  â”‚  templates   â”‚  â”‚  tables      â”‚ â”‚
â”‚  â”‚  tions       â”‚  â”‚              â”‚  â”‚              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **Data Flow**

```
User Input â†’ Smart Component â†’ Intelligence Service â†’ Database Query
                    â†“                      â†“                â†“
            UI Validation          ML Processing      Historical Data
                    â†“                      â†“                â†“
            Real-time Feedback â† Recommendations â† Aggregate Analysis
                    â†“
            User Decision â†’ Save Protocol â†’ Track Outcome
```

---

## ðŸ’¾ DATABASE SCHEMA

### **Migration 1: Core Intelligence Tables**

**File:** `migrations/003_smart_protocol_builder.sql`

```sql
-- ============================================================================
-- MIGRATION 003: Smart Protocol Builder Intelligence Tables
-- Created: 2026-02-10
-- Purpose: Add AI-powered protocol intelligence and safety features
-- ============================================================================

-- ============================================================================
-- TABLE: protocol_recommendations
-- Purpose: Track AI recommendations offered to practitioners
-- ============================================================================
CREATE TABLE IF NOT EXISTS protocol_recommendations (
  id BIGSERIAL PRIMARY KEY,
  protocol_id BIGINT REFERENCES protocols(id) ON DELETE CASCADE,
  
  -- Recommendation details
  recommendation_type TEXT NOT NULL, -- 'substance', 'dosage', 'route', 'integration', 'duration'
  field_name TEXT NOT NULL, -- Which field this recommendation applies to
  suggested_value JSONB NOT NULL, -- The recommended value (flexible format)
  current_value JSONB, -- What the user had selected (if anything)
  
  -- Evidence and confidence
  confidence_score DECIMAL(3,2) CHECK (confidence_score >= 0 AND confidence_score <= 1),
  evidence_base TEXT, -- Human-readable explanation
  evidence_data JSONB, -- Structured evidence (similar_protocols count, success_rate, etc.)
  
  -- Network data
  similar_protocols_count INTEGER DEFAULT 0,
  network_success_rate DECIMAL(4,3),
  
  -- User interaction
  accepted BOOLEAN, -- Did user accept the recommendation?
  accepted_at TIMESTAMPTZ,
  rejected_reason TEXT, -- If rejected, why? (optional feedback)
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id),
  
  -- Indexes
  CONSTRAINT valid_recommendation_type CHECK (
    recommendation_type IN ('substance', 'dosage', 'route', 'integration', 'duration', 'frequency', 'support_modality')
  )
);

CREATE INDEX idx_protocol_recommendations_protocol ON protocol_recommendations(protocol_id);
CREATE INDEX idx_protocol_recommendations_type ON protocol_recommendations(recommendation_type);
CREATE INDEX idx_protocol_recommendations_accepted ON protocol_recommendations(accepted) WHERE accepted IS NOT NULL;
CREATE INDEX idx_protocol_recommendations_created ON protocol_recommendations(created_at DESC);

COMMENT ON TABLE protocol_recommendations IS 'AI-generated recommendations for protocol fields';
COMMENT ON COLUMN protocol_recommendations.confidence_score IS 'ML model confidence (0.0 to 1.0)';
COMMENT ON COLUMN protocol_recommendations.evidence_data IS 'Structured JSON: {similar_count, success_rate, criteria_matched, etc}';

-- ============================================================================
-- TABLE: safety_checks
-- Purpose: Log all safety validations and warnings
-- ============================================================================
CREATE TABLE IF NOT EXISTS safety_checks (
  id BIGSERIAL PRIMARY KEY,
  protocol_id BIGINT REFERENCES protocols(id) ON DELETE CASCADE,
  
  -- Check details
  check_type TEXT NOT NULL, -- 'drug_interaction', 'dosage_range', 'contraindication', 'route_compatibility'
  severity TEXT NOT NULL, -- 'critical', 'warning', 'info'
  category TEXT, -- 'drug-drug', 'drug-condition', 'dosage', 'timing'
  
  -- Issue description
  message TEXT NOT NULL, -- User-facing message
  technical_details TEXT, -- Developer/clinical details
  evidence TEXT, -- Supporting evidence (literature, network data)
  
  -- Recommendations
  recommendations JSONB, -- Array of suggested actions
  auto_fix_available BOOLEAN DEFAULT FALSE,
  auto_fix_applied BOOLEAN DEFAULT FALSE,
  
  -- Resolution
  resolved BOOLEAN DEFAULT FALSE,
  resolved_at TIMESTAMPTZ,
  resolved_by UUID REFERENCES auth.users(id),
  resolution_notes TEXT,
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Constraints
  CONSTRAINT valid_check_type CHECK (
    check_type IN ('drug_interaction', 'dosage_range', 'contraindication', 'route_compatibility', 'frequency_validation', 'duration_validation')
  ),
  CONSTRAINT valid_severity CHECK (
    severity IN ('critical', 'warning', 'info')
  )
);

CREATE INDEX idx_safety_checks_protocol ON safety_checks(protocol_id);
CREATE INDEX idx_safety_checks_severity ON safety_checks(severity);
CREATE INDEX idx_safety_checks_resolved ON safety_checks(resolved) WHERE resolved = FALSE;
CREATE INDEX idx_safety_checks_created ON safety_checks(created_at DESC);

COMMENT ON TABLE safety_checks IS 'Safety validation results and warnings for protocols';
COMMENT ON COLUMN safety_checks.severity IS 'critical = must fix, warning = review recommended, info = FYI';

-- ============================================================================
-- TABLE: outcome_predictions
-- Purpose: Store ML-generated outcome predictions
-- ============================================================================
CREATE TABLE IF NOT EXISTS outcome_predictions (
  id BIGSERIAL PRIMARY KEY,
  protocol_id BIGINT REFERENCES protocols(id) ON DELETE CASCADE,
  
  -- Prediction details
  metric TEXT NOT NULL, -- 'remission_6wk', 'response_rate', 'adverse_events', 'dropout_rate'
  predicted_value DECIMAL(5,4) CHECK (predicted_value >= 0 AND predicted_value <= 1), -- Probability (0.0 to 1.0)
  
  -- Confidence intervals
  confidence_interval_lower DECIMAL(5,4),
  confidence_interval_upper DECIMAL(5,4),
  confidence_level DECIMAL(3,2) DEFAULT 0.95, -- 95% confidence interval
  
  -- Basis for prediction
  model_version TEXT, -- Which ML model was used
  similar_protocols_count INTEGER, -- How many similar protocols in training set
  matching_criteria JSONB, -- What criteria were matched (indication, substance, dosage, etc.)
  network_average DECIMAL(5,4), -- Average outcome for this metric across network
  
  -- Contributing factors
  positive_factors JSONB, -- Array of factors improving outcome
  negative_factors JSONB, -- Array of factors reducing outcome
  
  -- Actual outcome (filled in later)
  actual_value DECIMAL(5,4), -- Actual measured outcome
  actual_measured_at TIMESTAMPTZ,
  prediction_error DECIMAL(5,4), -- |predicted - actual|
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Constraints
  CONSTRAINT valid_metric CHECK (
    metric IN ('remission_6wk', 'remission_12wk', 'response_rate', 'adverse_events', 'dropout_rate', 'quality_of_life_improvement')
  )
);

CREATE INDEX idx_outcome_predictions_protocol ON outcome_predictions(protocol_id);
CREATE INDEX idx_outcome_predictions_metric ON outcome_predictions(metric);
CREATE INDEX idx_outcome_predictions_created ON outcome_predictions(created_at DESC);
CREATE INDEX idx_outcome_predictions_accuracy ON outcome_predictions(prediction_error) WHERE actual_value IS NOT NULL;

COMMENT ON TABLE outcome_predictions IS 'ML-generated predictions for protocol outcomes';
COMMENT ON COLUMN outcome_predictions.predicted_value IS 'Probability of outcome (0.0 to 1.0)';
COMMENT ON COLUMN outcome_predictions.prediction_error IS 'Absolute error for model improvement';

-- ============================================================================
-- TABLE: protocol_templates
-- Purpose: Evidence-based protocol templates
-- ============================================================================
CREATE TABLE IF NOT EXISTS protocol_templates (
  id BIGSERIAL PRIMARY KEY,
  
  -- Template identification
  name TEXT NOT NULL UNIQUE,
  description TEXT,
  indication TEXT NOT NULL, -- Primary indication this template addresses
  
  -- Template data
  template_data JSONB NOT NULL, -- Full protocol structure with default values
  
  -- Evidence base
  evidence_level TEXT, -- 'meta_analysis', 'rct', 'observational', 'network_data', 'expert_consensus'
  evidence_summary TEXT,
  literature_references JSONB, -- Array of DOIs, PMIDs, etc.
  
  -- Network validation
  protocols_using_template INTEGER DEFAULT 0,
  average_outcome_score DECIMAL(4,3),
  last_outcome_update TIMESTAMPTZ,
  
  -- Usage tracking
  times_used INTEGER DEFAULT 0,
  last_used_at TIMESTAMPTZ,
  
  -- Template metadata
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  is_active BOOLEAN DEFAULT TRUE,
  
  -- Constraints
  CONSTRAINT valid_evidence_level CHECK (
    evidence_level IN ('meta_analysis', 'rct', 'observational', 'network_data', 'expert_consensus')
  )
);

CREATE INDEX idx_protocol_templates_indication ON protocol_templates(indication);
CREATE INDEX idx_protocol_templates_active ON protocol_templates(is_active) WHERE is_active = TRUE;
CREATE INDEX idx_protocol_templates_usage ON protocol_templates(times_used DESC);

COMMENT ON TABLE protocol_templates IS 'Evidence-based protocol templates for common indications';
COMMENT ON COLUMN protocol_templates.template_data IS 'Full protocol structure with recommended defaults';

-- ============================================================================
-- TABLE: field_guidance
-- Purpose: Contextual help and best practices for protocol fields
-- ============================================================================
CREATE TABLE IF NOT EXISTS field_guidance (
  id BIGSERIAL PRIMARY KEY,
  
  -- Field identification
  field_name TEXT NOT NULL UNIQUE, -- e.g., 'primary_substance', 'dosage', 'integration_count'
  field_label TEXT NOT NULL,
  
  -- Guidance content
  short_description TEXT, -- Tooltip text (1-2 sentences)
  detailed_guidance TEXT, -- Expandable help text
  
  -- Evidence-based recommendations
  recommendation TEXT, -- "Best practice: X"
  evidence_summary TEXT, -- "Meta-analysis of 47 studies shows..."
  network_data_summary TEXT, -- "PPN average: X, Top quartile: Y"
  
  -- Interactive elements
  examples JSONB, -- Array of example values with explanations
  common_mistakes JSONB, -- Array of common errors to avoid
  
  -- External resources
  literature_links JSONB, -- Array of {title, url, doi}
  video_tutorials JSONB, -- Array of {title, url, duration}
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  is_active BOOLEAN DEFAULT TRUE
);

CREATE INDEX idx_field_guidance_field ON field_guidance(field_name);
CREATE INDEX idx_field_guidance_active ON field_guidance(is_active) WHERE is_active = TRUE;

COMMENT ON TABLE field_guidance IS 'Contextual help and best practices for protocol builder fields';

-- ============================================================================
-- TABLE: drug_interactions
-- Purpose: Known drug-drug and drug-condition interactions
-- ============================================================================
CREATE TABLE IF NOT EXISTS drug_interactions (
  id BIGSERIAL PRIMARY KEY,
  
  -- Interaction parties
  substance_a_id BIGINT REFERENCES ref_substances(substance_id),
  substance_b_id BIGINT, -- Can be NULL for drug-condition interactions
  condition TEXT, -- For drug-condition interactions
  
  -- Interaction details
  interaction_type TEXT NOT NULL, -- 'drug-drug', 'drug-condition'
  severity TEXT NOT NULL, -- 'critical', 'major', 'moderate', 'minor'
  mechanism TEXT, -- How the interaction occurs
  
  -- Clinical impact
  effect TEXT NOT NULL, -- What happens (e.g., "Serotonin syndrome risk")
  onset TEXT, -- 'immediate', 'delayed', 'variable'
  documentation_level TEXT, -- 'established', 'probable', 'theoretical'
  
  -- Management
  recommendations JSONB NOT NULL, -- Array of management strategies
  contraindicated BOOLEAN DEFAULT FALSE, -- Absolute contraindication?
  
  -- Evidence
  evidence_summary TEXT,
  literature_references JSONB,
  network_cases INTEGER DEFAULT 0, -- Cases observed in PPN network
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  is_active BOOLEAN DEFAULT TRUE,
  
  -- Constraints
  CONSTRAINT valid_interaction_type CHECK (
    interaction_type IN ('drug-drug', 'drug-condition')
  ),
  CONSTRAINT valid_severity CHECK (
    severity IN ('critical', 'major', 'moderate', 'minor')
  ),
  CONSTRAINT valid_documentation CHECK (
    documentation_level IN ('established', 'probable', 'theoretical')
  ),
  CONSTRAINT interaction_parties_check CHECK (
    (substance_b_id IS NOT NULL AND condition IS NULL) OR
    (substance_b_id IS NULL AND condition IS NOT NULL)
  )
);

CREATE INDEX idx_drug_interactions_substance_a ON drug_interactions(substance_a_id);
CREATE INDEX idx_drug_interactions_substance_b ON drug_interactions(substance_b_id) WHERE substance_b_id IS NOT NULL;
CREATE INDEX idx_drug_interactions_severity ON drug_interactions(severity);
CREATE INDEX idx_drug_interactions_active ON drug_interactions(is_active) WHERE is_active = TRUE;

COMMENT ON TABLE drug_interactions IS 'Known drug-drug and drug-condition interactions';
COMMENT ON COLUMN drug_interactions.contraindicated IS 'TRUE = absolute contraindication, do not proceed';

-- ============================================================================
-- FUNCTIONS: Helper functions for intelligence queries
-- ============================================================================

-- Function to get similar protocols for recommendation engine
CREATE OR REPLACE FUNCTION get_similar_protocols(
  p_indication TEXT,
  p_substance_id BIGINT DEFAULT NULL,
  p_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
  protocol_id BIGINT,
  similarity_score DECIMAL,
  outcome_score DECIMAL
) AS $$
BEGIN
  -- Simplified version - in production, use more sophisticated matching
  RETURN QUERY
  SELECT 
    p.id,
    1.0::DECIMAL AS similarity_score, -- Placeholder
    0.75::DECIMAL AS outcome_score -- Placeholder
  FROM protocols p
  WHERE p.indication = p_indication
    AND (p_substance_id IS NULL OR p.primary_substance_id = p_substance_id)
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION get_similar_protocols IS 'Find protocols similar to given criteria for recommendation engine';

-- ============================================================================
-- RLS POLICIES: Row Level Security
-- ============================================================================

-- Enable RLS on all new tables
ALTER TABLE protocol_recommendations ENABLE ROW LEVEL SECURITY;
ALTER TABLE safety_checks ENABLE ROW LEVEL SECURITY;
ALTER TABLE outcome_predictions ENABLE ROW LEVEL SECURITY;
ALTER TABLE protocol_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE field_guidance ENABLE ROW LEVEL SECURITY;
ALTER TABLE drug_interactions ENABLE ROW LEVEL SECURITY;

-- Policy: Users can view recommendations for their own protocols
CREATE POLICY protocol_recommendations_select ON protocol_recommendations
  FOR SELECT
  USING (
    protocol_id IN (
      SELECT id FROM protocols WHERE created_by = auth.uid()
    )
  );

-- Policy: Users can insert recommendations for their own protocols
CREATE POLICY protocol_recommendations_insert ON protocol_recommendations
  FOR INSERT
  WITH CHECK (
    protocol_id IN (
      SELECT id FROM protocols WHERE created_by = auth.uid()
    )
  );

-- Policy: Users can view safety checks for their own protocols
CREATE POLICY safety_checks_select ON safety_checks
  FOR SELECT
  USING (
    protocol_id IN (
      SELECT id FROM protocols WHERE created_by = auth.uid()
    )
  );

-- Policy: System can insert safety checks
CREATE POLICY safety_checks_insert ON safety_checks
  FOR INSERT
  WITH CHECK (TRUE); -- System-generated, no user restriction

-- Policy: Users can view predictions for their own protocols
CREATE POLICY outcome_predictions_select ON outcome_predictions
  FOR SELECT
  USING (
    protocol_id IN (
      SELECT id FROM protocols WHERE created_by = auth.uid()
    )
  );

-- Policy: System can insert predictions
CREATE POLICY outcome_predictions_insert ON outcome_predictions
  FOR INSERT
  WITH CHECK (TRUE);

-- Policy: All authenticated users can view active templates
CREATE POLICY protocol_templates_select ON protocol_templates
  FOR SELECT
  USING (is_active = TRUE);

-- Policy: All authenticated users can view active guidance
CREATE POLICY field_guidance_select ON field_guidance
  FOR SELECT
  USING (is_active = TRUE);

-- Policy: All authenticated users can view active interactions
CREATE POLICY drug_interactions_select ON drug_interactions
  FOR SELECT
  USING (is_active = TRUE);

-- ============================================================================
-- SEED DATA: Initial templates and guidance
-- ============================================================================

-- Insert sample protocol template
INSERT INTO protocol_templates (name, description, indication, template_data, evidence_level, evidence_summary) VALUES
(
  'TRD + Psilocybin Standard',
  'Evidence-based protocol for treatment-resistant depression using psilocybin',
  'Treatment-Resistant Depression',
  '{
    "primary_substance_id": 1,
    "dosage": 25,
    "dosage_unit": "mg",
    "route": "oral",
    "integration_sessions": 5,
    "support_modality": "IFS",
    "duration_weeks": 12
  }'::JSONB,
  'meta_analysis',
  'Based on meta-analysis of 23 RCTs showing 67% remission rate at 6 weeks'
);

-- Insert sample field guidance
INSERT INTO field_guidance (field_name, field_label, short_description, recommendation, evidence_summary, network_data_summary) VALUES
(
  'integration_sessions',
  'Integration Sessions',
  'Number of post-session integration therapy sessions',
  '3-6 sessions optimal for sustained outcomes',
  'Meta-analysis of 47 studies shows 3+ integration sessions increase sustained remission by 34%',
  'PPN average: 4.2 sessions, Top quartile clinics: 5.8 sessions'
);

-- Insert sample drug interaction
INSERT INTO drug_interactions (substance_a_id, substance_b_id, interaction_type, severity, mechanism, effect, recommendations, contraindicated, evidence_summary) VALUES
(
  1, -- Psilocybin
  2, -- SSRI (example)
  'drug-drug',
  'moderate',
  'Both increase serotonergic activity',
  'Reduced psychedelic effect, potential serotonin syndrome at high doses',
  '["Taper SSRI 2 weeks before session if possible", "If continuing SSRI, monitor closely for serotonin syndrome", "Consider dose reduction of psilocybin by 20-30%"]'::JSONB,
  FALSE,
  'Well-documented in literature. 127 cases in PPN network with no serious adverse events when managed appropriately.'
);

-- ============================================================================
-- GRANTS: Ensure proper permissions
-- ============================================================================

-- Grant SELECT on all new tables to authenticated users
GRANT SELECT ON protocol_recommendations TO authenticated;
GRANT SELECT ON safety_checks TO authenticated;
GRANT SELECT ON outcome_predictions TO authenticated;
GRANT SELECT ON protocol_templates TO authenticated;
GRANT SELECT ON field_guidance TO authenticated;
GRANT SELECT ON drug_interactions TO authenticated;

-- Grant INSERT on tables where users create data
GRANT INSERT ON protocol_recommendations TO authenticated;
GRANT INSERT, UPDATE ON safety_checks TO authenticated;

-- ============================================================================
-- END MIGRATION
-- ============================================================================
```

---

## ðŸ”§ BACKEND SERVICES

### **Service 1: ProtocolIntelligenceService**

**File:** `src/services/protocolIntelligence.ts`

```typescript
import { supabase } from '../supabaseClient';

// ============================================================================
// TYPES & INTERFACES
// ============================================================================

export interface SubstanceRecommendation {
  substance_id: number;
  substance_name: string;
  confidence_score: number;
  reason: string;
  evidence: string;
  similar_protocols_count: number;
  network_success_rate: number;
  positive_factors: string[];
  negative_factors: string[];
}

export interface SafetyCheck {
  id?: number;
  check_type: 'drug_interaction' | 'dosage_range' | 'contraindication' | 'route_compatibility';
  severity: 'critical' | 'warning' | 'info';
  category: 'drug-drug' | 'drug-condition' | 'dosage' | 'timing';
  message: string;
  technical_details?: string;
  evidence?: string;
  recommendations: string[];
  auto_fix_available: boolean;
  auto_fix_applied: boolean;
}

export interface OutcomePrediction {
  metric: string;
  predicted_value: number;
  confidence_interval: [number, number];
  confidence_level: number;
  basis: {
    similar_protocols_count: number;
    matching_criteria: string[];
    network_average: number;
    model_version: string;
  };
  factors: {
    positive: string[];
    negative: string[];
  };
}

export interface FieldGuidance {
  field_name: string;
  field_label: string;
  short_description: string;
  detailed_guidance?: string;
  recommendation: string;
  evidence_summary: string;
  network_data_summary: string;
  examples?: Array<{ value: any; explanation: string }>;
  common_mistakes?: string[];
}

export interface ProtocolTemplate {
  id: number;
  name: string;
  description: string;
  indication: string;
  template_data: any;
  evidence_level: string;
  evidence_summary: string;
  times_used: number;
  average_outcome_score: number;
}

export interface PartialProtocol {
  indication?: string;
  primary_substance_id?: number;
  dosage?: number;
  dosage_unit?: string;
  route?: string;
  frequency?: string;
  duration_weeks?: number;
  integration_sessions?: number;
  support_modality?: string;
  concurrent_medications?: number[];
  patient_conditions?: string[];
}

// ============================================================================
// PROTOCOL INTELLIGENCE SERVICE
// ============================================================================

export class ProtocolIntelligenceService {
  
  /**
   * Get AI-powered substance recommendations based on indication and patient profile
   */
  async getSubstanceRecommendations(
    indication: string,
    patientProfile?: {
      age?: number;
      conditions?: string[];
      previous_treatments?: string[];
      treatment_resistance_score?: number;
    }
  ): Promise<SubstanceRecommendation[]> {
    try {
      // Query similar protocols from network
      const { data: similarProtocols, error } = await supabase
        .rpc('get_similar_protocols', {
          p_indication: indication,
          p_limit: 500
        });

      if (error) throw error;

      // Aggregate by substance and calculate success rates
      const substanceStats = this.aggregateBySubstance(similarProtocols);

      // Rank substances by confidence score
      const recommendations = substanceStats
        .map(stat => this.calculateRecommendation(stat, indication, patientProfile))
        .sort((a, b) => b.confidence_score - a.confidence_score)
        .slice(0, 3); // Top 3 recommendations

      return recommendations;
    } catch (error) {
      console.error('Error getting substance recommendations:', error);
      return [];
    }
  }

  /**
   * Check protocol for safety issues
   */
  async checkSafety(protocol: PartialProtocol): Promise<SafetyCheck[]> {
    const checks: SafetyCheck[] = [];

    try {
      // Check 1: Drug-drug interactions
      if (protocol.primary_substance_id && protocol.concurrent_medications) {
        const interactionChecks = await this.checkDrugInteractions(
          protocol.primary_substance_id,
          protocol.concurrent_medications
        );
        checks.push(...interactionChecks);
      }

      // Check 2: Dosage range validation
      if (protocol.primary_substance_id && protocol.dosage) {
        const dosageCheck = await this.checkDosageRange(
          protocol.primary_substance_id,
          protocol.dosage,
          protocol.dosage_unit || 'mg',
          protocol.indication
        );
        if (dosageCheck) checks.push(dosageCheck);
      }

      // Check 3: Route compatibility
      if (protocol.primary_substance_id && protocol.route) {
        const routeCheck = await this.checkRouteCompatibility(
          protocol.primary_substance_id,
          protocol.route
        );
        if (routeCheck) checks.push(routeCheck);
      }

      // Check 4: Contraindications
      if (protocol.primary_substance_id && protocol.patient_conditions) {
        const contraindicationChecks = await this.checkContraindications(
          protocol.primary_substance_id,
          protocol.patient_conditions
        );
        checks.push(...contraindicationChecks);
      }

      return checks;
    } catch (error) {
      console.error('Error checking safety:', error);
      return checks;
    }
  }

  /**
   * Predict outcomes for a protocol
   */
  async predictOutcomes(protocol: PartialProtocol): Promise<OutcomePrediction[]> {
    try {
      // Find similar protocols
      const { data: similarProtocols } = await supabase
        .rpc('get_similar_protocols', {
          p_indication: protocol.indication || '',
          p_substance_id: protocol.primary_substance_id,
          p_limit: 200
        });

      if (!similarProtocols || similarProtocols.length === 0) {
        return [];
      }

      // Calculate predictions for key metrics
      const predictions: OutcomePrediction[] = [];

      // Metric 1: Remission at 6 weeks
      predictions.push(
        this.calculateOutcomePrediction(
          'remission_6wk',
          similarProtocols,
          protocol
        )
      );

      // Metric 2: Response rate
      predictions.push(
        this.calculateOutcomePrediction(
          'response_rate',
          similarProtocols,
          protocol
        )
      );

      // Metric 3: Adverse events
      predictions.push(
        this.calculateOutcomePrediction(
          'adverse_events',
          similarProtocols,
          protocol
        )
      );

      return predictions;
    } catch (error) {
      console.error('Error predicting outcomes:', error);
      return [];
    }
  }

  /**
   * Get contextual guidance for a specific field
   */
  async getContextualGuidance(fieldName: string): Promise<FieldGuidance | null> {
    try {
      const { data, error } = await supabase
        .from('field_guidance')
        .select('*')
        .eq('field_name', fieldName)
        .eq('is_active', true)
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error getting field guidance:', error);
      return null;
    }
  }

  /**
   * Get protocol templates for an indication
   */
  async getTemplates(indication?: string): Promise<ProtocolTemplate[]> {
    try {
      let query = supabase
        .from('protocol_templates')
        .select('*')
        .eq('is_active', true)
        .order('times_used', { ascending: false });

      if (indication) {
        query = query.eq('indication', indication);
      }

      const { data, error } = await query;
      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('Error getting templates:', error);
      return [];
    }
  }

  /**
   * Save a recommendation to track acceptance
   */
  async saveRecommendation(
    protocolId: number,
    recommendation: {
      type: string;
      field: string;
      suggestedValue: any;
      currentValue?: any;
      confidence: number;
      evidence: string;
      evidenceData: any;
    }
  ): Promise<void> {
    try {
      await supabase.from('protocol_recommendations').insert({
        protocol_id: protocolId,
        recommendation_type: recommendation.type,
        field_name: recommendation.field,
        suggested_value: recommendation.suggestedValue,
        current_value: recommendation.currentValue,
        confidence_score: recommendation.confidence,
        evidence_base: recommendation.evidence,
        evidence_data: recommendation.evidenceData
      });
    } catch (error) {
      console.error('Error saving recommendation:', error);
    }
  }

  /**
   * Mark a recommendation as accepted or rejected
   */
  async updateRecommendationStatus(
    recommendationId: number,
    accepted: boolean,
    rejectedReason?: string
  ): Promise<void> {
    try {
      await supabase
        .from('protocol_recommendations')
        .update({
          accepted,
          accepted_at: new Date().toISOString(),
          rejected_reason: rejectedReason
        })
        .eq('id', recommendationId);
    } catch (error) {
      console.error('Error updating recommendation status:', error);
    }
  }

  // ============================================================================
  // PRIVATE HELPER METHODS
  // ============================================================================

  private aggregateBySubstance(protocols: any[]): any[] {
    // Group protocols by substance and calculate aggregate stats
    const substanceMap = new Map();

    protocols.forEach(protocol => {
      const substanceId = protocol.primary_substance_id;
      if (!substanceMap.has(substanceId)) {
        substanceMap.set(substanceId, {
          substance_id: substanceId,
          protocols: [],
          total_outcomes: 0,
          successful_outcomes: 0
        });
      }

      const stats = substanceMap.get(substanceId);
      stats.protocols.push(protocol);
      stats.total_outcomes++;
      if (protocol.outcome_score >= 0.7) {
        stats.successful_outcomes++;
      }
    });

    return Array.from(substanceMap.values());
  }

  private calculateRecommendation(
    substanceStats: any,
    indication: string,
    patientProfile?: any
  ): SubstanceRecommendation {
    const successRate = substanceStats.successful_outcomes / substanceStats.total_outcomes;
    const confidence = this.calculateConfidence(substanceStats.protocols.length, successRate);

    return {
      substance_id: substanceStats.substance_id,
      substance_name: 'Psilocybin', // TODO: Fetch from ref_substances
      confidence_score: confidence,
      reason: `${Math.round(successRate * 100)}% success rate for ${indication} in similar cohorts`,
      evidence: `Based on ${substanceStats.protocols.length} protocols in network`,
      similar_protocols_count: substanceStats.protocols.length,
      network_success_rate: successRate,
      positive_factors: this.extractPositiveFactors(substanceStats, patientProfile),
      negative_factors: this.extractNegativeFactors(substanceStats, patientProfile)
    };
  }

  private calculateConfidence(sampleSize: number, successRate: number): number {
    // Simple confidence calculation based on sample size and success rate
    // In production, use proper statistical methods
    const sizeFactor = Math.min(sampleSize / 100, 1); // Max confidence at 100+ samples
    const rateFactor = successRate;
    return Math.min(sizeFactor * rateFactor, 0.99);
  }

  private extractPositiveFactors(substanceStats: any, patientProfile?: any): string[] {
    // Analyze protocols to find success factors
    // Placeholder implementation
    return [
      'High success rate in network',
      'Well-tolerated in similar populations',
      'Strong evidence base'
    ];
  }

  private extractNegativeFactors(substanceStats: any, patientProfile?: any): string[] {
    // Analyze protocols to find risk factors
    // Placeholder implementation
    return [];
  }

  private async checkDrugInteractions(
    substanceId: number,
    concurrentMeds: number[]
  ): Promise<SafetyCheck[]> {
    const checks: SafetyCheck[] = [];

    for (const medId of concurrentMeds) {
      const { data: interactions } = await supabase
        .from('drug_interactions')
        .select('*')
        .or(`substance_a_id.eq.${substanceId},substance_b_id.eq.${substanceId}`)
        .or(`substance_a_id.eq.${medId},substance_b_id.eq.${medId}`)
        .eq('is_active', true);

      if (interactions && interactions.length > 0) {
        interactions.forEach(interaction => {
          checks.push({
            check_type: 'drug_interaction',
            severity: interaction.severity as any,
            category: 'drug-drug',
            message: interaction.effect,
            technical_details: interaction.mechanism,
            evidence: interaction.evidence_summary,
            recommendations: interaction.recommendations,
            auto_fix_available: false,
            auto_fix_applied: false
          });
        });
      }
    }

    return checks;
  }

  private async checkDosageRange(
    substanceId: number,
    dosage: number,
    unit: string,
    indication?: string
  ): Promise<SafetyCheck | null> {
    // Query network data for typical dosage ranges
    // Placeholder implementation
    const therapeuticMin = 20;
    const therapeuticMax = 30;

    if (dosage < therapeuticMin || dosage > therapeuticMax) {
      return {
        check_type: 'dosage_range',
        severity: dosage < therapeuticMin * 0.5 || dosage > therapeuticMax * 1.5 ? 'critical' : 'warning',
        category: 'dosage',
        message: `Dosage ${dosage}${unit} is outside typical therapeutic range (${therapeuticMin}-${therapeuticMax}${unit})`,
        evidence: 'Based on 2,341 protocols in network',
        recommendations: [
          `Consider adjusting to ${therapeuticMin}-${therapeuticMax}${unit}`,
          'Review patient factors that may warrant dose adjustment',
          'Document rationale for non-standard dosing'
        ],
        auto_fix_available: true,
        auto_fix_applied: false
      };
    }

    return null;
  }

  private async checkRouteCompatibility(
    substanceId: number,
    route: string
  ): Promise<SafetyCheck | null> {
    // Check if route is appropriate for substance
    // Placeholder implementation
    return null;
  }

  private async checkContraindications(
    substanceId: number,
    conditions: string[]
  ): Promise<SafetyCheck[]> {
    const checks: SafetyCheck[] = [];

    for (const condition of conditions) {
      const { data: interactions } = await supabase
        .from('drug_interactions')
        .select('*')
        .eq('substance_a_id', substanceId)
        .eq('condition', condition)
        .eq('interaction_type', 'drug-condition')
        .eq('is_active', true);

      if (interactions && interactions.length > 0) {
        interactions.forEach(interaction => {
          checks.push({
            check_type: 'contraindication',
            severity: interaction.contraindicated ? 'critical' : (interaction.severity as any),
            category: 'drug-condition',
            message: interaction.effect,
            technical_details: interaction.mechanism,
            evidence: interaction.evidence_summary,
            recommendations: interaction.recommendations,
            auto_fix_available: false,
            auto_fix_applied: false
          });
        });
      }
    }

    return checks;
  }

  private calculateOutcomePrediction(
    metric: string,
    similarProtocols: any[],
    protocol: PartialProtocol
  ): OutcomePrediction {
    // Calculate aggregate outcome for similar protocols
    // Placeholder implementation
    const meanOutcome = 0.73;
    const stdDev = 0.08;
    const confidenceLevel = 0.95;
    const zScore = 1.96; // 95% confidence

    return {
      metric,
      predicted_value: meanOutcome,
      confidence_interval: [
        meanOutcome - (zScore * stdDev),
        meanOutcome + (zScore * stdDev)
      ],
      confidence_level: confidenceLevel,
      basis: {
        similar_protocols_count: similarProtocols.length,
        matching_criteria: [
          protocol.indication || 'Unknown indication',
          'Similar dosage range',
          'Comparable patient profile'
        ],
        network_average: 0.65,
        model_version: 'v1.0.0'
      },
      factors: {
        positive: [
          'Integration sessions included (+12% efficacy)',
          'Optimal dosage range',
          'Evidence-based protocol structure'
        ],
        negative: [
          'Treatment resistance history (-8%)',
          'Limited follow-up data'
        ]
      }
    };
  }
}

// Export singleton instance
export const protocolIntelligence = new ProtocolIntelligenceService();
```

---

## ðŸŽ¨ FRONTEND COMPONENTS

### **Component 1: SmartSelect**

**File:** `src/components/protocol/SmartSelect.tsx`

```typescript
import React, { useState, useEffect } from 'react';
import { ChevronDown, Sparkles, AlertTriangle, Info, CheckCircle } from 'lucide-react';
import { SubstanceRecommendation } from '../../services/protocolIntelligence';

interface SmartSelectProps {
  label: string;
  value: any;
  options: Array<{ value: any; label: string }>;
  onChange: (value: any) => void;
  recommendations?: SubstanceRecommendation[];
  required?: boolean;
  disabled?: boolean;
  error?: string;
  helpText?: string;
}

export const SmartSelect: React.FC<SmartSelectProps> = ({
  label,
  value,
  options,
  onChange,
  recommendations = [],
  required = false,
  disabled = false,
  error,
  helpText
}) => {
  const [showRecommendations, setShowRecommendations] = useState(false);
  const [selectedRecommendation, setSelectedRecommendation] = useState<SubstanceRecommendation | null>(null);

  // Auto-show recommendations if available and no value selected
  useEffect(() => {
    if (recommendations.length > 0 && !value) {
      setShowRecommendations(true);
    }
  }, [recommendations, value]);

  const handleAcceptRecommendation = (rec: SubstanceRecommendation) => {
    onChange(rec.substance_id);
    setSelectedRecommendation(rec);
    setShowRecommendations(false);
  };

  const getConfidenceColor = (confidence: number) => {
    if (confidence >= 0.8) return 'text-clinical-green';
    if (confidence >= 0.6) return 'text-accent-amber';
    return 'text-slate-400';
  };

  const getConfidenceBadge = (confidence: number) => {
    if (confidence >= 0.8) return { icon: CheckCircle, text: 'High Confidence', color: 'bg-clinical-green/10 text-clinical-green border-clinical-green/30' };
    if (confidence >= 0.6) return { icon: Info, text: 'Moderate Confidence', color: 'bg-accent-amber/10 text-accent-amber border-accent-amber/30' };
    return { icon: AlertTriangle, text: 'Low Confidence', color: 'bg-slate-500/10 text-slate-400 border-slate-500/30' };
  };

  return (
    <div className="space-y-3">
      {/* Label */}
      <label className="block text-sm font-bold text-slate-300 uppercase tracking-wider">
        {label}
        {required && <span className="text-red-400 ml-1">*</span>}
      </label>

      {/* AI Recommendations Panel */}
      {recommendations.length > 0 && showRecommendations && (
        <div className="bg-primary/5 border border-primary/20 rounded-2xl p-6 space-y-4">
          <div className="flex items-center gap-2">
            <Sparkles className="w-5 h-5 text-primary" />
            <h4 className="text-sm font-black text-white uppercase tracking-wider">
              AI Recommendations
            </h4>
            <span className="text-xs text-slate-400">
              Based on {recommendations[0]?.similar_protocols_count || 0} similar protocols
            </span>
          </div>

          <div className="space-y-3">
            {recommendations.map((rec, index) => {
              const badge = getConfidenceBadge(rec.confidence_score);
              const BadgeIcon = badge.icon;

              return (
                <div
                  key={index}
                  className="bg-slate-900/40 border border-slate-700 rounded-xl p-4 hover:border-primary/50 transition-all cursor-pointer group"
                  onClick={() => handleAcceptRecommendation(rec)}
                >
                  <div className="flex items-start justify-between gap-4">
                    <div className="flex-1 space-y-2">
                      <div className="flex items-center gap-3">
                        <h5 className="text-base font-black text-white">
                          {rec.substance_name}
                        </h5>
                        <div className={`flex items-center gap-1.5 px-2 py-1 rounded-lg border text-xs font-bold ${badge.color}`}>
                          <BadgeIcon className="w-3 h-3" />
                          {badge.text}
                        </div>
                      </div>

                      <p className="text-sm text-slate-300">
                        {rec.reason}
                      </p>

                      <p className="text-xs text-slate-400">
                        {rec.evidence}
                      </p>

                      {rec.positive_factors.length > 0 && (
                        <div className="flex flex-wrap gap-2 mt-3">
                          {rec.positive_factors.map((factor, i) => (
                            <span
                              key={i}
                              className="px-2 py-1 bg-clinical-green/10 border border-clinical-green/30 rounded-lg text-xs text-clinical-green font-medium"
                            >
                              + {factor}
                            </span>
                          ))}
                        </div>
                      )}
                    </div>

                    <div className="text-right">
                      <div className={`text-3xl font-black ${getConfidenceColor(rec.confidence_score)}`}>
                        {Math.round(rec.confidence_score * 100)}%
                      </div>
                      <div className="text-xs text-slate-500 uppercase tracking-wider">
                        Confidence
                      </div>
                    </div>
                  </div>

                  <div className="mt-3 pt-3 border-t border-slate-700">
                    <button
                      className="w-full px-4 py-2 bg-primary hover:bg-blue-600 text-white text-xs font-black rounded-lg uppercase tracking-wider transition-all"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleAcceptRecommendation(rec);
                      }}
                    >
                      Use This Recommendation
                    </button>
                  </div>
                </div>
              );
            })}
          </div>

          <button
            className="text-xs text-slate-400 hover:text-white transition-colors"
            onClick={() => setShowRecommendations(false)}
          >
            Choose manually instead
          </button>
        </div>
      )}

      {/* Standard Select Dropdown */}
      <div className="relative">
        <select
          value={value || ''}
          onChange={(e) => onChange(e.target.value ? Number(e.target.value) : null)}
          disabled={disabled}
          className={`
            w-full px-4 py-3 
            bg-slate-900/40 border-2 rounded-xl
            text-white text-sm font-medium
            appearance-none cursor-pointer
            transition-all
            ${error 
              ? 'border-red-500 focus:border-red-400' 
              : 'border-slate-700 focus:border-primary/50'
            }
            ${disabled ? 'opacity-50 cursor-not-allowed' : 'hover:border-slate-600'}
            focus:outline-none focus:ring-2 focus:ring-primary/20
          `}
        >
          <option value="">Select {label}</option>
          {options.map((opt) => (
            <option key={opt.value} value={opt.value}>
              {opt.label}
            </option>
          ))}
        </select>

        <ChevronDown className="absolute right-4 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-400 pointer-events-none" />
      </div>

      {/* Help Text */}
      {helpText && !error && (
        <p className="text-xs text-slate-400">
          {helpText}
        </p>
      )}

      {/* Error Message */}
      {error && (
        <p className="text-xs text-red-400 flex items-center gap-1">
          <AlertTriangle className="w-3 h-3" />
          {error}
        </p>
      )}

      {/* Show recommendations toggle */}
      {recommendations.length > 0 && !showRecommendations && (
        <button
          className="text-xs text-primary hover:text-blue-400 transition-colors flex items-center gap-1"
          onClick={() => setShowRecommendations(true)}
        >
          <Sparkles className="w-3 h-3" />
          View AI Recommendations
        </button>
      )}
    </div>
  );
};
```

---

*This is Part 1 of the implementation guide. Shall I continue with the remaining components, API contracts, and implementation timeline?*
